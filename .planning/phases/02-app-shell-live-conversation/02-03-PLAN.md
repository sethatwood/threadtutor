---
phase: 02-app-shell-live-conversation
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - components/conversation-panel.tsx
  - components/conversation-shell.tsx
  - components/topic-picker.tsx
  - app/page.tsx
autonomous: false

must_haves:
  truths:
    - "User sees a topic picker on first visit with example topic chips and free text input"
    - "User can enter an API key that persists in localStorage across sessions"
    - "Returning users with a saved API key skip the key entry step and go straight to topic selection"
    - "After selecting a topic, the three-panel layout appears with ConceptMap (left ~25%), Conversation (center ~50%), LearningJournal (right ~25%)"
    - "Claude's first response appears automatically after the conversation starts (opening turn)"
    - "User can type responses in an auto-growing textarea with Enter to send and Shift+Enter for newline"
    - "When a confidence check is pending, the main input is disabled and the check card's embedded input is active"
    - "A shimmer skeleton appears while waiting for Claude's response"
    - "The conversation auto-scrolls to the bottom when new messages appear"
    - "The header shows ThreadTutor branding and the current topic"
  artifacts:
    - path: "components/conversation-panel.tsx"
      provides: "Message list with scroll management, input area, and conversation flow"
      exports: ["ConversationPanel"]
    - path: "components/conversation-shell.tsx"
      provides: "Three-panel desktop layout with header"
      exports: ["ConversationShell"]
    - path: "components/topic-picker.tsx"
      provides: "Topic selection and API key entry flow"
      exports: ["TopicPicker"]
    - path: "app/page.tsx"
      provides: "Entry point rendering TopicPicker"
  key_links:
    - from: "components/conversation-panel.tsx"
      to: "lib/use-conversation.ts"
      via: "useConversation hook for state and sendMessage"
      pattern: "useConversation"
    - from: "components/conversation-panel.tsx"
      to: "components/message.tsx"
      via: "renders Message for each turn"
      pattern: "Message"
    - from: "components/conversation-panel.tsx"
      to: "components/confidence-check.tsx"
      via: "renders ConfidenceCheckCard inside Message children"
      pattern: "ConfidenceCheckCard"
    - from: "components/conversation-panel.tsx"
      to: "components/skeleton-message.tsx"
      via: "renders SkeletonMessage during loading"
      pattern: "SkeletonMessage"
    - from: "components/conversation-shell.tsx"
      to: "components/conversation-panel.tsx"
      via: "renders ConversationPanel in center panel"
      pattern: "ConversationPanel"
    - from: "components/conversation-shell.tsx"
      to: "components/concept-map-placeholder.tsx"
      via: "renders placeholder in left panel"
      pattern: "ConceptMapPlaceholder"
    - from: "components/conversation-shell.tsx"
      to: "components/journal-placeholder.tsx"
      via: "renders placeholder in right panel"
      pattern: "JournalPlaceholder"
    - from: "components/topic-picker.tsx"
      to: "components/conversation-shell.tsx"
      via: "renders ConversationShell after topic selected"
      pattern: "ConversationShell"
    - from: "components/topic-picker.tsx"
      to: "lib/api-key.ts"
      via: "reads/writes API key from localStorage"
      pattern: "getApiKey|setApiKey"
    - from: "app/page.tsx"
      to: "components/topic-picker.tsx"
      via: "renders TopicPicker as page content"
      pattern: "TopicPicker"
---

<objective>
Assemble all Phase 2 components into the working application: the conversation panel (message list + input + scroll management), three-panel shell layout, topic picker with API key entry, and updated page entry point. After this plan, the user can open the app, enter a topic and API key, and have a live Socratic conversation with Claude.

Purpose: This is the final assembly plan that wires everything together. Plans 01 and 02 built the foundations and leaf components; this plan composes them into the full interactive experience.

Output: Four files that complete the Phase 2 user experience, plus a human verification checkpoint.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-app-shell-live-conversation/02-CONTEXT.md
@.planning/phases/02-app-shell-live-conversation/02-RESEARCH.md
@.planning/phases/02-app-shell-live-conversation/02-01-SUMMARY.md
@.planning/phases/02-app-shell-live-conversation/02-02-SUMMARY.md
@lib/types.ts
@lib/api-key.ts
@lib/use-conversation.ts
@components/message.tsx
@components/confidence-check.tsx
@components/skeleton-message.tsx
@components/concept-map-placeholder.tsx
@components/journal-placeholder.tsx
@app/api/chat/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conversation panel with message list and input</name>
  <files>components/conversation-panel.tsx</files>
  <action>
    Create a `"use client"` component that is the center panel's content.

    Props: `{ topic: string; apiKey: string }`

    This component:
    1. **Uses the conversation hook:** Call `useConversation(topic, apiKey)` to get state and sendMessage.

    2. **Triggers the opening turn:** Use a `useEffect` that runs once on mount. Send an empty-ish opening message like "I'd like to learn about [topic]" to kick off the conversation. This triggers Claude's opening Socratic turn. Guard against double-fire with a ref.

    3. **Renders the message list:** Map over `state.turns` and render a `<Message>` for each turn. For assistant turns that have a `confidenceCheck`:
       - If it's the LAST turn with a confidence check AND `state.pendingConfidenceCheck` is true, pass a `<ConfidenceCheckCard>` as children with `isPending={true}` and an `onSubmit` handler that calls `sendMessage(answer)`.
       - If the confidence check already has an `assessment` (from a previous turn's response), pass `<ConfidenceCheckCard>` with `isPending={false}` (shows assessment result, no input).

    4. **Shows skeleton during loading:** When `state.isLoading` is true, render a `<SkeletonMessage />` after the last message.

    5. **Auto-scrolls to bottom:** Use a ref on a sentinel div at the bottom of the message list. Scroll into view (smooth) whenever `state.turns` changes or `state.isLoading` changes.

    6. **Main input area:** At the bottom, render an auto-growing textarea with:
       - Enter-to-send, Shift+Enter for newline (same pattern as in confidence-check.tsx)
       - Disabled when `state.isLoading` is true OR `state.pendingConfidenceCheck` is true
       - Placeholder text: "Type your response..." (or "Answer the question above..." when confidence check pending)
       - A send button that is disabled when input is empty, loading, or confidence check pending
       - On send: call `sendMessage(inputValue)`, clear the input, reset textarea height

    7. **Error display:** If `state.error` is not null, show an error banner above the input area with the error message and a dismiss button that calls `clearError()`. Style with muted red (bg-rose-50, text-rose-700, border border-rose-200).

    Layout: The component should be a flex column that fills its container. The message list scrolls (overflow-y-auto, flex-1), and the input area is pinned at the bottom.
  </action>
  <verify>
    Run `npm run build` to confirm the component compiles.
    Verify it imports useConversation, Message, ConfidenceCheckCard, SkeletonMessage.
    Verify the opening turn useEffect exists.
    Verify the input area has enter-to-send logic.
  </verify>
  <done>Conversation panel renders the full message flow: opening turn trigger, message list with inline confidence checks, skeleton loading, auto-scroll, error display, and a main input area with enter-to-send that disables during loading and confidence checks.</done>
</task>

<task type="auto">
  <name>Task 2: Create three-panel shell, topic picker, and update page entry point</name>
  <files>components/conversation-shell.tsx, components/topic-picker.tsx, app/page.tsx</files>
  <action>
    **components/conversation-shell.tsx:** Create a `"use client"` component for the three-panel desktop layout.

    Props: `{ topic: string; apiKey: string; onBack?: () => void }`

    Layout:
    - Full viewport height (h-screen), flex column
    - **Header:** A horizontal bar with:
      - "ThreadTutor" branding on the left (font-semibold)
      - Current topic name displayed (text-sm text-zinc-500, with separator)
      - Optional "New topic" or back button on the right that calls `onBack` (allows returning to topic picker)
      - Bottom border for visual separation
    - **Three-panel body:** flex-1, flex row, overflow-hidden
      - Left panel: w-1/4, border-r, renders `<ConceptMapPlaceholder />`
      - Center panel: w-1/2, flex column, renders `<ConversationPanel topic={topic} apiKey={apiKey} />`
      - Right panel: w-1/4, border-l, renders `<JournalPlaceholder />`

    Design: Subtle thin borders between panels. Clean, minimal. No heavy visual chrome.

    **components/topic-picker.tsx:** Create a `"use client"` component for the session start flow.

    Internal state:
    - `topic: string` (input value)
    - `apiKey: string` (input value, initialized from localStorage via useEffect)
    - `apiKeyLoaded: boolean` (false until useEffect reads localStorage)
    - `started: boolean` (false until user starts the conversation)
    - `showApiKeyInput: boolean` (true when user needs to enter key)

    Flow:
    1. **On mount:** Read API key from localStorage using `getApiKey()` in a useEffect. Set `apiKeyLoaded = true`. If key exists, `showApiKeyInput = false` (returning user skips key entry).

    2. **Topic selection screen** (when not started):
       - Centered layout with generous whitespace
       - "What would you like to learn about?" heading (large, clean)
       - Free text input for topic (large, prominent, placeholder: "Enter any topic...")
       - Example topic chips below the input as clickable pills. Suggested topics: "Bitcoin mining", "Photosynthesis", "How compilers work", "The French Revolution", "Quantum entanglement". Clicking a chip fills the topic input.
       - A "Start learning" button below (or Enter to submit if topic is non-empty)

    3. **API key entry** (shown inline after clicking "Start learning" if no key in localStorage):
       - After user enters a topic and clicks "Start learning", if no API key is stored:
         - Show an inline section below the topic with: "Enter your Anthropic API key to begin" label
         - A password-type input for the API key
         - A small help text: "Your key is stored in your browser only and sent directly to Anthropic."
         - "Begin conversation" button
       - On submit: call `setApiKey(key)` to persist, then set `started = true`
       - If the key already exists (returning user): skip this step, set `started = true` immediately

    4. **Transition to conversation** (when started is true):
       - Render `<ConversationShell topic={topic} apiKey={apiKey} onBack={handleBack} />`
       - The `handleBack` function resets `started = false` to return to topic picker

    Design notes (from CONTEXT.md):
    - Topic picker is front and center on first visit
    - Clean and minimal (Notion-like), generous whitespace
    - Example topic chips should be inviting

    **app/page.tsx:** Update the existing page to render `<TopicPicker />` as the main content. This is a server component that renders the client component.

    ```tsx
    import { TopicPicker } from "@/components/topic-picker";

    export default function Home() {
      return <TopicPicker />;
    }
    ```

    Remove the existing placeholder content (the centered heading and description).
  </action>
  <verify>
    Run `npm run build` to confirm all files compile.
    Run `npm run dev` and verify the app loads the topic picker at localhost:3000.
    Verify the three-panel layout renders when a topic is selected.
  </verify>
  <done>The app renders a topic picker on first visit, accepts an API key (persisted in localStorage), and transitions to a three-panel conversation layout. The header shows branding and topic. Users can return to the topic picker via the back button.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete Phase 2 interactive experience: topic picker with API key entry, three-panel layout with conversation panel, live Socratic conversation with Claude via the API, markdown-rendered responses, confidence check cards with embedded input, and shimmer loading states.
  </what-built>
  <how-to-verify>
    1. Run `npm run dev` and open http://localhost:3000
    2. Verify the topic picker appears with example topic chips and a text input
    3. Enter a topic (or click a chip) and click "Start learning"
    4. Enter your Anthropic API key when prompted (or verify it's skipped if already saved)
    5. Verify the three-panel layout appears: Concept Map placeholder (left), Conversation (center), Learning Journal placeholder (right)
    6. Verify Claude's opening message appears with markdown formatting (headings, bold, lists render properly)
    7. Type a response and press Enter -- verify it sends and Claude responds
    8. Wait for a confidence check (every 2-3 turns) -- verify it appears as a colored card with an embedded input
    9. Answer the confidence check -- verify the assessment result appears (tracking/partial/confused badge)
    10. Verify the shimmer skeleton appears while waiting for responses
    11. Verify the header shows "ThreadTutor" and the topic name
    12. Refresh the page, verify the API key is remembered (goes straight to topic picker, no key prompt)
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues to fix</resume-signal>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with no errors
2. App loads at localhost:3000 with topic picker
3. Topic selection and API key entry flow works end-to-end
4. Three-panel layout renders correctly (25% | 50% | 25%)
5. Live conversation with Claude works (messages send and receive)
6. Markdown renders with proper typography (headings, lists, bold visible)
7. Confidence checks render as colored cards with embedded input
8. Assessment results show as muted-color badges
9. Shimmer skeleton appears during loading
10. Enter-to-send and Shift+Enter-for-newline work
11. Main input disables when confidence check is pending
12. API key persists in localStorage across page reloads
13. Error messages display with dismiss capability
</verification>

<success_criteria>
Phase 2 is functionally complete: a user can visit the app, enter a topic and API key, and have a multi-turn live Socratic conversation with Claude. The three-panel desktop layout is present, Claude's responses render with proper markdown formatting, confidence checks appear as distinct cards with embedded input, and the loading experience uses shimmer skeletons. The API key persists across sessions in localStorage.
</success_criteria>

<output>
After completion, create `.planning/phases/02-app-shell-live-conversation/02-03-SUMMARY.md`
</output>
