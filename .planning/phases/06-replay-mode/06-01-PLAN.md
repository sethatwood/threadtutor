---
phase: 06-replay-mode
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/use-interval.ts
  - lib/use-replay-state.ts
  - components/replay-conversation.tsx
  - components/replay-controls.tsx
  - components/replay-shell.tsx
autonomous: true

must_haves:
  truths:
    - "Stepping forward reveals the next turn in the conversation, concept map, and journal"
    - "Stepping backward hides the most recent turn from all three panels"
    - "Auto-play advances turns every 2.5 seconds and stops at the end"
    - "Confidence checks in replay display the assessment and feedback (never show a pending input form)"
  artifacts:
    - path: "lib/use-interval.ts"
      provides: "Declarative setInterval hook with null-to-pause"
      exports: ["useInterval"]
    - path: "lib/use-replay-state.ts"
      provides: "Replay state machine: currentIndex, visibleTurns, next/back/toggleAutoPlay"
      exports: ["useReplayState"]
    - path: "components/replay-conversation.tsx"
      provides: "Read-only message list with assessed confidence checks, no input area"
      exports: ["ReplayConversation"]
    - path: "components/replay-controls.tsx"
      provides: "Next/Back/Auto-play toolbar with progress indicator"
      exports: ["ReplayControls"]
    - path: "components/replay-shell.tsx"
      provides: "Three-panel replay layout composing ConceptMap, ReplayConversation, LearningJournal, and ReplayControls"
      exports: ["ReplayShell"]
  key_links:
    - from: "lib/use-replay-state.ts"
      to: "lib/use-interval.ts"
      via: "import useInterval for auto-play timer"
      pattern: "useInterval.*isPlaying"
    - from: "components/replay-shell.tsx"
      to: "lib/use-replay-state.ts"
      via: "useReplayState hook call with session"
      pattern: "useReplayState\\(session\\)"
    - from: "components/replay-shell.tsx"
      to: "components/concept-map.tsx"
      via: "turns={replay.visibleTurns} prop"
      pattern: "ConceptMap.*visibleTurns"
    - from: "components/replay-conversation.tsx"
      to: "components/message.tsx"
      via: "reuses Message component for turn rendering"
      pattern: "import.*Message"
---

<objective>
Create the replay mode infrastructure: useReplayState hook with auto-play timer, ReplayConversation and ReplayControls UI components, and ReplayShell three-panel layout.

Purpose: Provides the complete replay viewing experience as a set of composable pieces. ReplayShell can accept any Session and render a step-through replay of it.
Output: Five new files (two hooks, three components) that together deliver turn-by-turn replay with forward/back stepping and auto-play.
</objective>

<execution_context>
@/Users/yayseth/.claude/get-shit-done/workflows/execute-plan.md
@/Users/yayseth/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/06-replay-mode/06-RESEARCH.md
@.planning/phases/03-concept-map/03-02-SUMMARY.md
@.planning/phases/05-session-persistence/05-02-SUMMARY.md

@lib/types.ts
@components/conversation-panel.tsx
@components/conversation-shell.tsx
@components/concept-map.tsx
@components/learning-journal.tsx
@components/message.tsx
@components/confidence-check.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useInterval and useReplayState hooks</name>
  <files>lib/use-interval.ts, lib/use-replay-state.ts</files>
  <action>
    Create `lib/use-interval.ts` implementing Dan Abramov's declarative useInterval pattern:
    - Accept `callback: () => void` and `delay: number | null`
    - Use `useRef` to store the latest callback (avoids stale closures)
    - `useEffect` to sync callback ref on every render
    - `useEffect` dependent on `delay` that sets up/clears the interval
    - When `delay` is `null`, skip interval setup (pause behavior)
    - Export as named export `useInterval`

    Create `lib/use-replay-state.ts`:
    - Accept a `Session` parameter
    - State: `currentIndex` (number, starts at 0), `isPlaying` (boolean, starts at false)
    - Derived: `visibleTurns = session.turns.slice(0, currentIndex + 1)`, `totalTurns = session.turns.length`, `isAtStart = currentIndex === 0`, `isAtEnd = currentIndex === totalTurns - 1`
    - `next()`: increment currentIndex clamped to totalTurns - 1
    - `back()`: decrement currentIndex clamped to 0, also set isPlaying to false (manual back stops auto-play)
    - `toggleAutoPlay()`: toggle isPlaying boolean
    - Use `useInterval` with delay `isPlaying ? 2500 : null` for auto-play timer
    - In the interval callback: if at end (`currentIndex >= totalTurns - 1`), call `setIsPlaying(false)` and return; otherwise call `next()`
    - Return object: `{ visibleTurns, currentIndex, totalTurns, isPlaying, isAtStart, isAtEnd, next, back, toggleAutoPlay }`
    - Import Session type from `@/lib/types`
  </action>
  <verify>Check TypeScript compilation: `npx tsc --noEmit lib/use-interval.ts lib/use-replay-state.ts` (or run full `npm run build` at the end)</verify>
  <done>useInterval hook handles declarative interval with pause, useReplayState hook manages turn index with forward/back/auto-play and derives visibleTurns slice</done>
</task>

<task type="auto">
  <name>Task 2: Create ReplayConversation and ReplayControls components</name>
  <files>components/replay-conversation.tsx, components/replay-controls.tsx</files>
  <action>
    Create `components/replay-conversation.tsx`:
    - "use client" directive
    - Accept prop `turns: Turn[]`
    - Render a scrollable message list using the existing `Message` component (import from `@/components/message`)
    - For assistant turns with `confidenceCheck` that has a truthy `assessment`: render `ConfidenceCheckCard` with `isPending={false}` and `check={turn.confidenceCheck}` as a child of `Message`
    - NEVER render `isPending={true}` -- replay mode has no interactive confidence checks
    - Auto-scroll to bottom when turns change (same useEffect + scrollRef pattern as ConversationPanel)
    - No input area, no error banner, no loading skeleton
    - Styled identically to the message list portion of ConversationPanel: `flex h-full flex-col`, message area `flex-1 overflow-y-auto px-6`

    Create `components/replay-controls.tsx`:
    - "use client" directive
    - Props interface matching what useReplayState returns: `currentIndex`, `totalTurns`, `isPlaying`, `isAtStart`, `isAtEnd`, `next`, `back`, `toggleAutoPlay`
    - Render a horizontal toolbar at the bottom:
      - Back button (disabled when `isAtStart`)
      - Play/Pause toggle button: shows "Auto-play" when paused, "Pause" when playing. Use text labels (no icons needed).
      - Next button (disabled when `isAtEnd`)
      - Progress indicator: `{currentIndex + 1} / {totalTurns}` text in zinc-400
    - Style the toolbar with `border-t border-zinc-800 px-6 py-3 flex items-center justify-center gap-4`
    - Button style: `rounded-md px-3 py-1.5 text-sm` with zinc-400 text, hover:bg-zinc-800, disabled:opacity-40 disabled:cursor-not-allowed
    - Auto-play button gets a subtle visual difference when playing: `text-indigo-400` instead of `text-zinc-400`
  </action>
  <verify>Check TypeScript compilation: `npx tsc --noEmit components/replay-conversation.tsx components/replay-controls.tsx`</verify>
  <done>ReplayConversation renders turns as read-only messages with assessed confidence checks; ReplayControls provides Next/Back/Auto-play toolbar with progress indicator</done>
</task>

<task type="auto">
  <name>Task 3: Create ReplayShell three-panel layout</name>
  <files>components/replay-shell.tsx</files>
  <action>
    Create `components/replay-shell.tsx`:
    - "use client" directive
    - Props: `session: Session` and `onBack?: () => void`
    - Call `useReplayState(session)` to get replay state
    - Click-to-scroll handler: `handleConceptClick(turnNumber)` using `document.querySelector('[data-turn-number="..."]')?.scrollIntoView({ behavior: "smooth", block: "start" })` (same pattern as ConversationShell)
    - Layout mirrors ConversationShell exactly:
      - Outer: `flex h-screen flex-col`
      - Header: `flex items-center justify-between border-b border-zinc-800 px-6 py-3`
        - Left: "ThreadTutor / {session.topic}" breadcrumb (same style as ConversationShell)
        - Right: "Replay" badge in `text-xs text-indigo-400 border border-indigo-500/30 rounded-full px-2.5 py-0.5` and an "Exit" button (calls onBack) if onBack is provided
      - Body: `flex flex-1 overflow-hidden`
        - Left (w-1/4): `ConceptMap` with `turns={replay.visibleTurns}` and `onConceptClick={handleConceptClick}`
        - Center (w-1/2, flex flex-col): `ReplayConversation` with `turns={replay.visibleTurns}` in the flex-1 area, `ReplayControls` below it
        - Right (w-1/4): `LearningJournal` with `turns={replay.visibleTurns}`
    - Import ConceptMap from `@/components/concept-map`, ReplayConversation from `@/components/replay-conversation`, LearningJournal from `@/components/learning-journal`, ReplayControls from `@/components/replay-controls`
  </action>
  <verify>`npm run build` succeeds with no TypeScript errors</verify>
  <done>ReplayShell renders the three-panel replay layout with ConceptMap, ReplayConversation, LearningJournal, and ReplayControls all driven by visibleTurns from useReplayState</done>
</task>

</tasks>

<verification>
1. `npm run build` passes with no TypeScript errors
2. All five new files exist and export their named components/hooks
3. ReplayShell accepts a Session and renders all three panels with replay controls
4. No modifications to existing files in this plan
</verification>

<success_criteria>
- useInterval hook handles declarative setInterval with null-to-pause
- useReplayState manages currentIndex with next/back/toggleAutoPlay and derives visibleTurns
- ReplayConversation renders turns read-only with assessed confidence checks (never pending)
- ReplayControls provides Next/Back/Auto-play toolbar with progress
- ReplayShell assembles the three-panel layout identical to ConversationShell but driven by replay state
- All TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/06-replay-mode/06-01-SUMMARY.md`
</output>
