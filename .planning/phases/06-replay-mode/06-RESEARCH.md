# Phase 6: Replay Mode - Research

**Researched:** 2026-02-15
**Domain:** React state-driven replay UI, progressive graph building, static JSON demo delivery
**Confidence:** HIGH

## Summary

Phase 6 adds a replay mode that lets visitors without API keys step through a pre-recorded Bitcoin proof-of-work demo session. The existing architecture makes this straightforward: `ConceptMap`, `ConversationPanel`, and `LearningJournal` all derive their display from a `Turn[]` prop. Replay is fundamentally "control which slice of turns is visible." A `useReplayState` hook manages a `currentIndex` into the demo session's turns array, and the three panels receive `turns.slice(0, currentIndex + 1)` instead of the full array. The concept map naturally builds and un-builds because `collectAllConcepts` and `buildGraphElements` are pure functions of the turns slice.

No new libraries are needed. The only new artifacts are: (1) a `useReplayState` hook managing turn index and auto-play timer, (2) a `ReplayShell` component analogous to `ConversationShell` but with stepper controls instead of an input box, (3) a `ReplayControls` UI component with Next/Back/Auto-play buttons, and (4) a `public/demo.json` file containing a pre-recorded Session. The demo.json is generated by running a live session in dev mode (which writes to `/public/sessions/` on disk) and then curating/committing it.

**Primary recommendation:** Build a `useReplayState` hook that owns `currentIndex` and an auto-play timer (Dan Abramov's `useInterval` pattern with `null` delay to pause), a `ReplayShell` that composes the three panels with sliced turns, and a `ReplayControls` toolbar. Wire into `TopicPicker` as the default experience when no API key is present.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| React (hooks) | 19.2.3 | `useReducer`/`useState` for turn index, `useEffect` for auto-play timer | Already in project; no external state library needed |
| Next.js public folder | 16.1.6 | Serve `demo.json` as a static file at `/demo.json` | Built-in Next.js convention for static assets |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| @xyflow/react | 12.10.0 | Concept map visualization (already installed) | ConceptMap receives sliced turns and works unchanged |
| @dagrejs/dagre | 2.0.4 | Graph layout (already installed) | Called via existing `buildGraphElements` |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Custom `useInterval` inline | `use-interval` npm package | Adds a dependency for 10 lines of code; not worth it for this project |
| `fetch('/demo.json')` at runtime | `import demo from '@/public/demo.json'` static import | Static import bundles the JSON into JS, inflating the client bundle. Fetch is better for a ~50KB session file |
| Separate replay page route (`/replay`) | Replay within same page, mode-switched | Phase 7 (Landing Experience) will handle mode transitions; keeping replay mode accessible from the same page is simpler for now |

**Installation:**
```bash
# No new packages needed. All dependencies already installed.
```

## Architecture Patterns

### Recommended File Structure
```
lib/
  use-replay-state.ts     # Hook: currentIndex, next/back/toggle auto-play
components/
  replay-shell.tsx         # Three-panel layout for replay mode (no input box)
  replay-controls.tsx      # Next/Back/Auto-play toolbar
public/
  demo.json                # Pre-recorded Bitcoin proof-of-work session
```

### Pattern 1: Turn-Slice Driven Replay
**What:** The replay hook manages a single integer `currentIndex`. All three panels receive `session.turns.slice(0, currentIndex + 1)` as their turns prop. The concept map, conversation, and journal naturally show only the visible portion.
**When to use:** Whenever the same components need to display a subset of a session's turns.
**Why it works:** `ConceptMap` derives nodes/edges via `useMemo(() => collectAllConcepts(turns), [turns])`. `LearningJournal` filters assistant turns with non-null `journalEntry`. `ConversationPanel` renders `state.turns.map(...)`. All three are pure functions of their turns input. Slicing the input is the simplest and most correct approach.

```typescript
// Source: Codebase analysis of existing components
function useReplayState(session: Session) {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);

  const totalTurns = session.turns.length;
  const visibleTurns = session.turns.slice(0, currentIndex + 1);

  const next = useCallback(() => {
    setCurrentIndex(i => Math.min(i + 1, totalTurns - 1));
  }, [totalTurns]);

  const back = useCallback(() => {
    setCurrentIndex(i => Math.max(i - 1, 0));
    setIsPlaying(false); // Stop auto-play on manual back
  }, []);

  const toggleAutoPlay = useCallback(() => {
    setIsPlaying(p => !p);
  }, []);

  // Auto-play: advance every 2.5s, stop at end
  useInterval(() => {
    if (currentIndex >= totalTurns - 1) {
      setIsPlaying(false);
      return;
    }
    next();
  }, isPlaying ? 2500 : null);

  return {
    visibleTurns,
    currentIndex,
    totalTurns,
    isPlaying,
    isAtStart: currentIndex === 0,
    isAtEnd: currentIndex === totalTurns - 1,
    next,
    back,
    toggleAutoPlay,
  };
}
```

### Pattern 2: Dan Abramov's useInterval Hook
**What:** A declarative `useInterval` that uses `useRef` to store the callback and accepts `null` delay to pause. Solves the stale closure problem with `setInterval` in React hooks.
**When to use:** Any time you need auto-play, polling, or periodic actions in React.

```typescript
// Source: https://overreacted.io/making-setinterval-declarative-with-react-hooks/
function useInterval(callback: () => void, delay: number | null) {
  const savedCallback = useRef<() => void>(callback);

  useEffect(() => {
    savedCallback.current = callback;
  });

  useEffect(() => {
    if (delay === null) return;
    const id = setInterval(() => savedCallback.current(), delay);
    return () => clearInterval(id);
  }, [delay]);
}
```

### Pattern 3: ReplayShell vs. ConversationShell
**What:** `ReplayShell` is a sibling to `ConversationShell`, not a modification of it. It composes the same child components (`ConceptMap`, `LearningJournal`) but replaces the center panel's input area with `ReplayControls` and renders `ConversationPanel`-like message display without the input textarea.
**When to use:** When the replay mode has fundamentally different interaction (stepping vs. typing) from live mode.
**Why separate:** `ConversationShell` manages live API calls, auto-save to localStorage, session IDs, and the `useConversation` hook. Replay needs none of this. Mixing both into one component via flags would create complexity. Two focused components are cleaner.

```typescript
// Sketch of ReplayShell structure
export function ReplayShell({ session, onBack }: ReplayShellProps) {
  const replay = useReplayState(session);

  return (
    <div className="flex h-screen flex-col">
      <header>...</header>
      <div className="flex flex-1 overflow-hidden">
        <ConceptMap turns={replay.visibleTurns} />
        <ReplayConversation turns={replay.visibleTurns} />
        <LearningJournal turns={replay.visibleTurns} />
      </div>
      <ReplayControls {...replay} />
    </div>
  );
}
```

### Pattern 4: Demo Session Loading
**What:** Fetch `demo.json` from the public folder at runtime. The file is the exact `Session` type (same format saved by Phase 5).
**When to use:** On initial page load when no API key is stored.

```typescript
// Fetch demo.json at runtime (not static import to avoid bundling)
async function loadDemoSession(): Promise<Session> {
  const response = await fetch('/demo.json');
  if (!response.ok) throw new Error('Failed to load demo session');
  return response.json();
}
```

### Anti-Patterns to Avoid
- **Mutating ConversationShell for replay:** Don't add `isReplay` flags to ConversationShell. Create a separate ReplayShell. The two modes have different concerns (API calls vs. index stepping).
- **Storing visible turns in state:** Don't copy turns into a separate state array. Derive `visibleTurns` from `session.turns.slice(0, currentIndex + 1)`. Derived state prevents sync bugs.
- **Using setTimeout chains for auto-play:** Don't chain setTimeout calls. Use setInterval with the useInterval pattern. setTimeout chains drift over time and are harder to pause/resume.
- **Importing demo.json statically:** Don't `import demoSession from '@/public/demo.json'` because it bundles the entire session (~30-50KB) into the JavaScript bundle. Fetch it at runtime instead.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Declarative setInterval | Custom setTimeout chain | Dan Abramov's `useInterval` pattern (inline, 10 lines) | Handles stale closures, cleanup, and null-to-pause correctly |
| Graph layout for replay | Custom node positioning | Existing `buildGraphElements` from `lib/graph-layout.ts` | Already handles dagre layout, orphaned nodes, and edge generation |
| Message rendering for replay | Custom message display | Existing `Message` component from `components/message.tsx` | Already handles markdown, role labels, data-turn-number attributes |
| Confidence check display | Custom check rendering | Existing `ConfidenceCheckCard` with `isPending: false` | Already shows assessment badge and feedback when not pending |

**Key insight:** The existing component library is replay-ready by design. `ConceptMap`, `Message`, `ConfidenceCheckCard`, and `LearningJournal` all accept turns/check data as props and render accordingly. The replay feature is primarily about controlling *which turns are visible*, not re-implementing display logic.

## Common Pitfalls

### Pitfall 1: Stale Closure in Auto-Play Timer
**What goes wrong:** Using `setInterval` directly in `useEffect` with captured `currentIndex` causes the timer to always read the initial value, advancing from 0 to 1 forever.
**Why it happens:** JavaScript closures capture variables at creation time. The interval callback closes over the initial `currentIndex` value.
**How to avoid:** Use the `useInterval` pattern with `useRef` for the callback. The ref always points to the latest callback which reads fresh state.
**Warning signs:** Auto-play gets "stuck" repeating the same transition.

### Pitfall 2: Auto-Play Doesn't Stop at End
**What goes wrong:** Auto-play keeps running after reaching the last turn, causing no visible effect but wasting cycles. Or worse, if bounds checking is off, `currentIndex` exceeds the array length.
**Why it happens:** The interval doesn't check whether it has reached the end of the turns array.
**How to avoid:** In the interval callback, check `currentIndex >= totalTurns - 1` and call `setIsPlaying(false)` to stop. Use `Math.min` in the `next` function as a safety net.
**Warning signs:** Play/pause button stays in "playing" state after the last turn.

### Pitfall 3: Concept Map Animations Fire on Every Back Step
**What goes wrong:** Stepping backwards causes concept-enter animations to replay on all visible nodes because the nodes array is re-derived from scratch each time.
**Why it happens:** The existing CSS `concept-enter` animation fires on every mount. When the turns slice shrinks and then grows again, React unmounts and remounts nodes.
**How to avoid:** The `isNew` flag in `ConceptNodeData` is already scoped to `turnNumber === latestTurnNumber`. When stepping back, the latestTurnNumber changes, so previously "new" nodes lose the glow. When stepping forward again, only the newly revealed turn's concepts get the `isNew` flag. This should work correctly without changes, but verify during implementation.
**Warning signs:** All nodes flash/animate when using the Back button.

### Pitfall 4: Confidence Checks Shown as "Pending" in Replay
**What goes wrong:** The existing `ConversationPanel` logic checks `state.pendingConfidenceCheck` to show the input form. If this flag is incorrectly set during replay, visitors see an interactive form they shouldn't interact with.
**Why it happens:** The replay mode reuses `ConversationPanel` logic which assumes a live session context.
**How to avoid:** In replay mode, never set `pendingConfidenceCheck: true`. All confidence checks in the demo session already have `assessment` and `feedback` filled in. The `ConfidenceCheckCard` component correctly renders the assessment badge when `isPending: false` and `check.assessment` is truthy. The replay conversation display should pass `pendingConfidenceCheck: false` always.
**Warning signs:** Textarea input appears inside a confidence check during replay.

### Pitfall 5: Demo Session Not Available on First Deploy
**What goes wrong:** `public/demo.json` is missing because it was never generated and committed. The fetch fails, and visitors see an error or blank screen.
**Why it happens:** The demo session must be generated by running a live conversation (with an API key) and saving the output. This is a manual step that's easy to forget.
**How to avoid:** Generate the demo session during Phase 6 implementation: run a live Bitcoin proof-of-work session in dev mode, curate the output, commit it as `public/demo.json`. Add error handling for the fetch: if demo.json fails to load, show a fallback message directing visitors to enter an API key.
**Warning signs:** 404 error on `/demo.json` in production.

### Pitfall 6: Click-to-Scroll Broken in Replay
**What goes wrong:** Clicking a concept node tries to scroll to a turn via `data-turn-number`, but the turn hasn't been revealed yet (it's beyond `currentIndex`).
**Why it happens:** The concept map shows concepts from visible turns, so their `turnNumber` values correspond to visible messages. This should work correctly because the concept map only shows concepts from `visibleTurns`. However, if click-to-scroll targets a DOM element that hasn't rendered yet, `querySelector` returns `null`.
**How to avoid:** The existing `handleConceptClick` already handles null gracefully (optional chaining: `el?.scrollIntoView(...)`). No change needed, but worth verifying.
**Warning signs:** Clicking nodes in the concept map does nothing during replay.

## Code Examples

Verified patterns from the existing codebase:

### Deriving Visible Turns (core replay mechanism)
```typescript
// Source: Codebase analysis -- this is how all three panels already work
const visibleTurns = session.turns.slice(0, currentIndex + 1);

// ConceptMap receives turns and derives graph:
// components/concept-map.tsx line 40
const concepts = useMemo(() => collectAllConcepts(turns), [turns]);

// LearningJournal filters assistant turns:
// components/learning-journal.tsx line 13-18
const entries = useMemo(() => {
  return turns
    .filter(
      (t): t is Turn & { journalEntry: string } =>
        t.role === "assistant" && t.journalEntry !== null,
    )
    .map((t, index) => ({
      number: index + 1,
      text: t.journalEntry,
      turnNumber: t.turnNumber,
    }));
}, [turns]);
```

### Replay-Mode Confidence Check Rendering
```typescript
// Source: components/conversation-panel.tsx lines 100-121 (adapted for replay)
// In replay, ALL confidence checks are already assessed.
// The existing ConfidenceCheckCard handles this:
if (turn.role === "assistant" && turn.confidenceCheck) {
  if (turn.confidenceCheck.assessment) {
    // Already assessed -- shows badge + feedback
    checkCard = (
      <ConfidenceCheckCard
        check={turn.confidenceCheck}
        isPending={false}
      />
    );
  }
  // No "isPending: true" branch in replay mode
}
```

### Fetching Demo Session
```typescript
// Source: Next.js public folder convention
// https://nextjs.org/docs/app/api-reference/file-conventions/public-folder
useEffect(() => {
  fetch('/demo.json')
    .then(res => {
      if (!res.ok) throw new Error('Demo not found');
      return res.json();
    })
    .then((data: Session) => setDemoSession(data))
    .catch(err => setDemoError(err.message));
}, []);
```

### useInterval Implementation (inline in project)
```typescript
// Source: https://overreacted.io/making-setinterval-declarative-with-react-hooks/
// Adapted to TypeScript
import { useEffect, useRef } from 'react';

export function useInterval(callback: () => void, delay: number | null) {
  const savedCallback = useRef(callback);

  useEffect(() => {
    savedCallback.current = callback;
  });

  useEffect(() => {
    if (delay === null) return;
    const id = setInterval(() => savedCallback.current(), delay);
    return () => clearInterval(id);
  }, [delay]);
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| setTimeout chains for auto-play | `useInterval` with null-to-pause | 2019 (Dan Abramov's post, still current) | Cleaner pause/resume, no stale closures |
| Separate state arrays for visible content | Derived slices from single source | React best practice since hooks | Eliminates sync bugs between "full" and "visible" data |
| Importing JSON statically | Runtime fetch from public/ | General best practice for large data | Keeps JS bundle small |

**Deprecated/outdated:**
- None relevant. The patterns here are stable React fundamentals.

## Open Questions

1. **Demo Session Generation**
   - What we know: The demo session must be a Bitcoin proof-of-work topic, generated by running a live session and saved as `public/demo.json`. The session format matches the existing `Session` type.
   - What's unclear: Whether to hand-write the demo.json or generate it via a live session and curate. A live-generated session will have natural Socratic flow but may need editing to ensure good concept graph structure (e.g., consistent parentId references, ~15-20 concepts).
   - Recommendation: Generate via live dev session, then manually review and lightly curate the JSON. Commit the curated version. The session should have 12-20 turns with 2-3 confidence checks.

2. **Replay Entry Point in TopicPicker**
   - What we know: Phase 7 (Landing Experience) handles the full visitor flow and mode indicators. Phase 6 just needs replay to work.
   - What's unclear: Exactly how to wire the replay into the existing TopicPicker flow. New visitors (no API key) should see the replay by default, but the current TopicPicker shows the topic input.
   - Recommendation: Add a "Watch Demo" button or auto-load replay for visitors with no API key. Keep it simple for Phase 6; Phase 7 will polish the landing flow. A "Watch Demo" button in TopicPicker that loads the demo session into ReplayShell is sufficient.

3. **Replay Conversation Display: Reuse ConversationPanel or New Component?**
   - What we know: `ConversationPanel` has an input textarea and send button that aren't needed in replay. It also has `state.isLoading`, `state.error`, and `state.pendingConfidenceCheck` concerns.
   - What's unclear: Whether to add a `readOnly` prop to ConversationPanel or create a simpler `ReplayConversation` component.
   - Recommendation: Create a lightweight `ReplayConversation` component that reuses the `Message` component and `ConfidenceCheckCard` but omits the input area, error banner, and loading skeleton. This is simpler than making ConversationPanel dual-purpose.

## Sources

### Primary (HIGH confidence)
- Codebase analysis of `lib/types.ts`, `lib/graph-layout.ts`, `lib/use-conversation.ts`, `lib/session-storage.ts` -- Session/Turn types, graph derivation, state management
- Codebase analysis of `components/concept-map.tsx`, `components/conversation-panel.tsx`, `components/conversation-shell.tsx`, `components/learning-journal.tsx`, `components/confidence-check.tsx`, `components/message.tsx` -- Component prop interfaces, rendering logic, confidence check states
- Codebase analysis of `components/topic-picker.tsx` -- Entry point flow, API key detection, session loading
- [Next.js public folder docs](https://nextjs.org/docs/app/api-reference/file-conventions/public-folder) -- Static file serving for demo.json
- [Dan Abramov: Making setInterval Declarative with React Hooks](https://overreacted.io/making-setinterval-declarative-with-react-hooks/) -- useInterval pattern for auto-play

### Secondary (MEDIUM confidence)
- `.planning/research/ARCHITECTURE.md` lines 290-312 -- Original replay stepping flow design (pre-implementation sketch)
- `.planning/phases/05-session-persistence/05-02-SUMMARY.md` -- Confirmed `initialSession` prop pattern and `restoreSession` callback

### Tertiary (LOW confidence)
- None. All findings are verified against the codebase or official sources.

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- No new libraries needed. Existing components are replay-ready by design.
- Architecture: HIGH -- The turn-slice pattern is a direct consequence of how the components already work. Verified by reading all component source.
- Pitfalls: HIGH -- Identified from direct codebase analysis and well-documented React patterns (useInterval). The stale closure pitfall is verified by Dan Abramov's authoritative writeup.

**Research date:** 2026-02-15
**Valid until:** 2026-03-15 (stable patterns, no moving targets)
