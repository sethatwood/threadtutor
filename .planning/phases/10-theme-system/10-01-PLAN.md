---
phase: 10-theme-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/globals.css
  - app/layout.tsx
  - lib/theme.tsx
  - components/app-header.tsx
autonomous: true

must_haves:
  truths:
    - "A toggle button in the header switches the entire app between dark and light visual appearances"
    - "Refreshing the page preserves the user's last chosen theme with no flash of the wrong theme"
    - "A first-time visitor sees dark or light theme matching their OS prefers-color-scheme setting"
    - "Switching themes produces a smooth 0.3s color transition, not a hard snap"
  artifacts:
    - path: "app/globals.css"
      provides: "CSS custom property palette for both themes under [data-theme] selectors"
      contains: "[data-theme=\"dark\"]"
    - path: "lib/theme.tsx"
      provides: "ThemeProvider context and useTheme hook with localStorage persistence and system preference detection"
      exports: ["ThemeProvider", "useTheme"]
    - path: "app/layout.tsx"
      provides: "Flash-prevention inline script and ThemeProvider wrapping"
      contains: "ThemeProvider"
    - path: "components/app-header.tsx"
      provides: "Theme toggle button using useTheme hook"
      contains: "useTheme"
  key_links:
    - from: "lib/theme.tsx"
      to: "localStorage"
      via: "getItem/setItem with key 'theme'"
      pattern: "localStorage\\.(get|set)Item.*theme"
    - from: "app/layout.tsx"
      to: "lib/theme.tsx"
      via: "ThemeProvider wrapping children"
      pattern: "<ThemeProvider>"
    - from: "components/app-header.tsx"
      to: "lib/theme.tsx"
      via: "useTheme hook for toggle"
      pattern: "useTheme"
    - from: "app/layout.tsx"
      to: "document.documentElement"
      via: "Inline script setting data-theme before paint"
      pattern: "data-theme"
---

<objective>
Create the theme system infrastructure: CSS custom property palette for dark and light themes, a React context provider with localStorage persistence and system preference detection, flash prevention, and a visible toggle button in the header.

Purpose: Establishes the foundation that all components will consume in Plan 02. After this plan, toggling the theme changes the CSS variables and the body background/text transition smoothly, even though individual components still use hardcoded Tailwind colors (Plan 02 migrates those).

Output: Theme-aware globals.css, ThemeProvider + useTheme in lib/theme.tsx, updated layout.tsx with flash prevention, toggle button in AppHeader.
</objective>

<execution_context>
@/Users/yayseth/.claude/get-shit-done/workflows/execute-plan.md
@/Users/yayseth/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Bitcoin Echo reference for exact color values and theme variable naming
@bitcoinecho-org/header.php (lines 76-116: CSS variable definitions for both themes)
@bitcoinecho-org/footer.php (lines 228-261: theme toggle JS logic)

# Current files to modify
@app/globals.css
@app/layout.tsx
@components/app-header.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define CSS custom property palette and transition rules</name>
  <files>app/globals.css</files>
  <action>
Replace the current hardcoded `:root` block with a `[data-theme="dark"]` and `[data-theme="light"]` selector pair defining the full color palette as CSS custom properties. Match Bitcoin Echo's naming and values:

**Dark theme (`[data-theme="dark"]`):**
- `--color-bg: #0a0a0a` (near-black, Bitcoin Echo dark bg)
- `--color-bg-elevated: #111111` (cards, tooltips, overlays)
- `--color-surface: #1a1a1a` (input backgrounds, concept nodes)
- `--color-border: #2a2a2a` (panel dividers, input borders)
- `--color-text: #e8e8e8` (primary text)
- `--color-text-muted: #888888` (secondary text, labels)
- `--color-text-dim: #555555` (tertiary text, placeholders)
- `--color-accent-indigo: #818cf8` (indigo accent for badges, labels)
- `--color-accent-indigo-hover: #a5b4fc` (indigo hover/highlight)
- `--color-accent-emerald: #34d399` (emerald accent)
- `--color-primary-bg: #4f46e5` (indigo-600, primary buttons)
- `--color-primary-bg-hover: #6366f1` (indigo-500, primary button hover)
- `--color-selection-bg: rgba(255, 255, 255, 0.2)` (text selection)

**Light theme (`[data-theme="light"]`):**
- `--color-bg: #f8f6f3` (warm off-white, Bitcoin Echo light bg)
- `--color-bg-elevated: #ffffff`
- `--color-surface: #eeebe6` (warm surface)
- `--color-border: #d4d0c8` (warm gray borders)
- `--color-text: #1a1a1a` (near-black text)
- `--color-text-muted: #5a5a5a`
- `--color-text-dim: #8a8a8a`
- `--color-accent-indigo: #4f46e5` (indigo-600, darker for light bg contrast)
- `--color-accent-indigo-hover: #4338ca` (indigo-700)
- `--color-accent-emerald: #059669` (emerald-600, darker for contrast)
- `--color-primary-bg: #4f46e5`
- `--color-primary-bg-hover: #4338ca`
- `--color-selection-bg: rgba(0, 0, 0, 0.15)`

Remove the old `--background` and `--foreground` vars. Update the `@theme inline` block to register `--color-bg` and `--color-text` as Tailwind theme values (replacing the old --color-background/--color-foreground).

Update the `body` rule to use `var(--color-bg)` and `var(--color-text)`, and add the smooth transition:
```css
body {
  background: var(--color-bg);
  color: var(--color-text);
  transition: background-color 0.3s ease, color 0.3s ease;
}
```

Add a global transition rule for theme-switching smoothness on common properties:
```css
*, *::before, *::after {
  transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease, box-shadow 0.3s ease;
}
```

IMPORTANT: The `*` transition rule should NOT apply `transition` to elements that have their OWN explicit transitions (like `concept-node` which has `transition: border-color 0.2s, box-shadow 0.2s`). Add the `*` rule with low specificity so component-level transitions naturally override it. Since the `*` selector has lower specificity than any class/element selector, this works by default.

Add text selection styling for both themes:
```css
[data-theme="dark"] ::selection {
  background: var(--color-selection-bg);
}
[data-theme="light"] ::selection {
  background: var(--color-selection-bg);
}
```

Update the React Flow dark mode overrides section to use the new CSS variables instead of hardcoded hex colors (--xy-background-color-default: transparent stays, --xy-node-background-color-default: var(--color-surface), --xy-node-color-default: var(--color-text), --xy-edge-stroke-default uses the indigo accent with alpha). Similarly update `.concept-node` background and border to use vars.

Update `.concept-node` to use `var(--color-surface)` for background and theme-appropriate border colors.

Update the shimmer skeleton gradient to use `var(--color-surface)` and `var(--color-border)` instead of hardcoded zinc.
  </action>
  <verify>
Run `npm run build` to confirm no CSS compilation errors. Grep globals.css for `data-theme` to confirm both selectors exist. Grep for the old `--background` and `--foreground` vars to confirm they are removed.
  </verify>
  <done>
globals.css defines complete dark and light palettes via [data-theme] selectors with CSS custom properties. Body uses var(--color-bg) and var(--color-text) with 0.3s transition. Old --background/--foreground vars are removed. React Flow overrides and concept-node styles use CSS variables.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ThemeProvider, flash-prevention script, and header toggle</name>
  <files>lib/theme.tsx, app/layout.tsx, components/app-header.tsx</files>
  <action>
**lib/theme.tsx** -- Create a React context provider and hook:

```tsx
"use client";

import { createContext, useContext, useEffect, useState, useCallback } from "react";

type Theme = "dark" | "light";

interface ThemeContextValue {
  theme: Theme;
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextValue | null>(null);

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<Theme>("dark");

  // On mount, read from DOM (already set by inline script in layout.tsx)
  useEffect(() => {
    const current = document.documentElement.getAttribute("data-theme") as Theme;
    if (current === "dark" || current === "light") {
      setTheme(current);
    }
  }, []);

  // Listen for system preference changes (only when user has no stored pref)
  useEffect(() => {
    const mq = window.matchMedia("(prefers-color-scheme: dark)");
    const handler = (e: MediaQueryListEvent) => {
      if (!localStorage.getItem("theme")) {
        const next = e.matches ? "dark" : "light";
        setTheme(next);
        document.documentElement.setAttribute("data-theme", next);
      }
    };
    mq.addEventListener("change", handler);
    return () => mq.removeEventListener("change", handler);
  }, []);

  const toggleTheme = useCallback(() => {
    setTheme((prev) => {
      const next = prev === "dark" ? "light" : "dark";
      document.documentElement.setAttribute("data-theme", next);
      localStorage.setItem("theme", next);
      return next;
    });
  }, []);

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const ctx = useContext(ThemeContext);
  if (!ctx) throw new Error("useTheme must be used within ThemeProvider");
  return ctx;
}
```

**app/layout.tsx** -- Two changes:

1. Add an inline `<script>` inside `<head>` (before any CSS paints) that prevents flash of wrong theme. This runs synchronously before React hydration:
```tsx
<script
  dangerouslySetInnerHTML={{
    __html: `(function(){try{var t=localStorage.getItem('theme');if(t){document.documentElement.setAttribute('data-theme',t)}else{var d=window.matchMedia('(prefers-color-scheme:dark)').matches;document.documentElement.setAttribute('data-theme',d?'dark':'light')}}catch(e){document.documentElement.setAttribute('data-theme','dark')}})()`,
  }}
/>
```

2. Wrap `{children}` with `<ThemeProvider>`. Import ThemeProvider from `@/lib/theme`. The ThemeProvider is a client component but can wrap server component children in App Router.

3. Set `data-theme="dark"` on the `<html>` element as the SSR default (the inline script overrides it before paint if needed):
```tsx
<html lang="en" data-theme="dark">
```

**components/app-header.tsx** -- Add the theme toggle button:

1. Convert to `"use client"` (it currently has no directive but is used inside client components, so this is safe and needed for the hook).

2. Import `useTheme` from `@/lib/theme`.

3. Add a theme toggle button to the right side of the header, between the mode badge and the children. The button shows a sun icon when in dark mode (clicking switches to light) and a moon icon in light mode (clicking switches to dark). Style it as a circular button matching Bitcoin Echo's `.theme-btn` pattern:

```tsx
const { theme, toggleTheme } = useTheme();

// In the header's right-side div, before {children}:
<button
  type="button"
  onClick={toggleTheme}
  aria-label={theme === "dark" ? "Switch to light mode" : "Switch to dark mode"}
  className="flex h-9 w-9 items-center justify-center rounded-full border border-[var(--color-border)] text-[var(--color-text-muted)] hover:border-[var(--color-text-dim)] hover:text-[var(--color-text)] transition-colors"
>
  {theme === "dark" ? (
    <svg className="h-[18px] w-[18px]" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
      <circle cx="12" cy="12" r="5" />
      <line x1="12" y1="1" x2="12" y2="3" />
      <line x1="12" y1="21" x2="12" y2="23" />
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64" />
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78" />
      <line x1="1" y1="12" x2="3" y2="12" />
      <line x1="21" y1="12" x2="23" y2="12" />
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36" />
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22" />
    </svg>
  ) : (
    <svg className="h-[18px] w-[18px]" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
      <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" />
    </svg>
  )}
</button>
```

The button uses inline CSS variable references (`var(--color-border)`, etc.) since Tailwind classes haven't been migrated to theme vars yet. This ensures the toggle button itself looks correct in both themes from the start.
  </action>
  <verify>
Run `npm run build` to confirm no build errors. Verify lib/theme.tsx exports ThemeProvider and useTheme. Verify layout.tsx includes the inline script and ThemeProvider wrapper. Verify app-header.tsx imports useTheme and renders the toggle button.
  </verify>
  <done>
ThemeProvider context with localStorage persistence and system preference detection is created in lib/theme.tsx. Layout.tsx has an inline script preventing theme flash and wraps children in ThemeProvider. AppHeader has a visible sun/moon toggle button that switches between dark and light themes. The theme state is reactive and persists across page refreshes.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with zero errors
2. `data-theme="dark"` and `data-theme="light"` selectors exist in globals.css with complete palettes
3. ThemeProvider exported from lib/theme.tsx and used in layout.tsx
4. Flash-prevention inline script present in layout.tsx head
5. Toggle button visible in AppHeader, clicking it switches `data-theme` attribute and persists to localStorage
6. Body background transitions smoothly (0.3s ease) when theme toggles
7. System preference (prefers-color-scheme) is respected for first-time visitors
</verification>

<success_criteria>
- The theme toggle button is visible and functional in the app header
- Clicking the toggle switches the body background between near-black (#0a0a0a) and warm off-white (#f8f6f3) with a smooth transition
- Refreshing preserves the chosen theme with no flash
- A fresh visit (no localStorage) respects the OS color scheme preference
- `npm run build` passes
</success_criteria>

<output>
After completion, create `.planning/phases/10-theme-system/10-01-SUMMARY.md`
</output>
